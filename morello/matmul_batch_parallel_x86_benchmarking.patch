diff --git a/morello/examples/matmul_batch_parallel_x86.rs b/morello/examples/matmul_batch_parallel_x86.rs
index 3f6732c8..0ab2816e 100644
--- a/morello/examples/matmul_batch_parallel_x86.rs
+++ b/morello/examples/matmul_batch_parallel_x86.rs
@@ -1,7 +1,6 @@
 use morello::codegen::CodeGen;
 use morello::imp::ImplNode;
 use morello::layout::{row_major, Layout, PhysDim};
-use morello::pprint::ImplPrintStyle;
 use morello::scheduling_sugar::{SchedulingSugar, Subschedule};
 use morello::spec;
 use morello::spec::Spec;
@@ -10,9 +9,8 @@ use morello::target::{
     CpuMemoryLevel::{GL, L1, RF, VRF},
     X86Target,
 };
-use morello::utils::ToWriteFmt;
 use nonzero::nonzero as nz;
-use std::io;
+use std::env;
 
 const M_C: u32 = 1020;
 const K_C: u32 = 1024;
@@ -22,9 +20,16 @@ const N_R: u32 = 16;
 const MOVE_TILE_SIZE: u32 = 32;
 
 fn main() {
+    let args = env::args().collect::<Vec<String>>();
+
     // Compute a batch=4 matrix multiplication. (Four independent matmuls!)
     let mut spec: Spec<X86Target> = spec!(MatmulAccum(
-        [4, 2048, 2048, 2048],
+        [
+            args[1].parse::<u32>().unwrap(),
+            args[2].parse::<u32>().unwrap(),
+            args[3].parse::<u32>().unwrap(),
+            args[4].parse::<u32>().unwrap(),
+        ],
         (f32, GL, row_major),
         (f32, GL, row_major),
         (f32, GL, row_major)
@@ -118,14 +123,6 @@ fn main() {
                 .subschedule(&[1, 2], naive_vector_move_impl)
         });
 
-    implementation
-        .emit(
-            true,
-            Some(ImplPrintStyle::Compact),
-            &mut ToWriteFmt(io::stdout()),
-        )
-        .unwrap_or_else(|e| panic!("Failed to generate code: {e}"));
-
     // If the verification flag is set, let's additionally double-check that the lowered
     // code builds and produces the correct results.
     #[cfg(feature = "verification")]
@@ -142,21 +139,10 @@ fn main() {
         }
     }
 
-    // Benchmark.
-    const ITERS: u32 = 10;
-    let result = implementation
-        .bench(ITERS, None)
-        .unwrap_or_else(|e| panic!("Failed to benchmark: {e}"));
-    let kernel_runtime =
-        (result.best_inner_loop_runtime() / result.inner_loop_iterations).as_secs_f64();
-    let throughput =
-        result.inner_loop_iterations as f64 / result.best_inner_loop_runtime().as_secs_f64();
-    println!("// kernel runtime: {kernel_runtime:.4}s ({throughput:.2}/sec)",);
-    println!(
-        "// {:.4} gigaFLOPs/sec (Spec is {} FLOPs)",
-        (spec.flops().unwrap() as f64 * throughput) / 1_000_000_000.0,
-        spec.flops().unwrap(),
-    );
+    let built_artifact = implementation
+        .build(true)
+        .unwrap_or_else(|e| panic!("Failed to build generated code: {e}"));
+    println!("{}", built_artifact.binary_path().display());
 }
 
 fn naive_scalar_move_impl(move_spec: &Spec<X86Target>) -> ImplNode<X86Target> {
