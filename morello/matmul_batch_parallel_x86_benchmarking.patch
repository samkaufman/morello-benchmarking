diff --git a/morello/examples/matmul_batch_parallel_x86.rs b/morello/examples/matmul_batch_parallel_x86.rs
index 89c288a1..27b7eddf 100644
--- a/morello/examples/matmul_batch_parallel_x86.rs
+++ b/morello/examples/matmul_batch_parallel_x86.rs
@@ -23,9 +23,16 @@ const N_R: u32 = 16;
 const MOVE_TILE_SIZE: u32 = 32;
 
 fn main() {
+    let args = std::env::args().collect::<Vec<String>>();
+
     // Compute a batch=4 matrix multiplication. (Four independent matmuls!)
     let mut spec: Spec<Avx2Target> = spec!(MatmulAccum(
-        [4, 2048, 2048, 2048],
+        [
+            args[1].parse::<u32>().unwrap(),
+            args[2].parse::<u32>().unwrap(),
+            args[3].parse::<u32>().unwrap(),
+            args[4].parse::<u32>().unwrap(),
+        ],
         (f32, GL, row_major),
         (f32, GL, row_major),
         (f32, GL, row_major)
@@ -107,14 +114,6 @@ fn main() {
                 .subschedule(&[1, 2], naive_vector_move_impl)
         });
 
-    implementation
-        .emit(
-            true,
-            Some(ImplPrintStyle::Compact),
-            &mut ToWriteFmt(io::stdout()),
-        )
-        .unwrap_or_else(|e| panic!("Failed to generate code: {e}"));
-
     // If the verification flag is set, let's additionally double-check that the lowered
     // code builds and produces the correct results.
     #[cfg(feature = "verification")]
@@ -131,21 +130,10 @@ fn main() {
         }
     }
 
-    // Benchmark.
-    const ITERS: u32 = 10;
-    let result = implementation
-        .bench(ITERS, None)
-        .unwrap_or_else(|e| panic!("Failed to benchmark: {e}"));
-    let kernel_runtime =
-        (result.best_inner_loop_runtime() / result.inner_loop_iterations).as_secs_f64();
-    let throughput =
-        result.inner_loop_iterations as f64 / result.best_inner_loop_runtime().as_secs_f64();
-    println!("// kernel runtime: {kernel_runtime:.4}s ({throughput:.2}/sec)",);
-    println!(
-        "// {:.4} gigaFLOPs/sec (Spec is {} FLOPs)",
-        (spec.flops().unwrap() as f64 * throughput) / 1_000_000_000.0,
-        spec.flops().unwrap(),
-    );
+    let built_artifact = implementation
+        .build(true)
+        .unwrap_or_else(|e| panic!("Failed to build generated code: {e}"));
+    println!("{}", built_artifact.binary_path().display());
 }
 
 fn naive_scalar_move_impl(move_spec: &Spec<Avx2Target>) -> ImplNode<Avx2Target> {
