diff --git a/morello/examples/matmul_batch_parallel_x86.rs b/morello/examples/matmul_batch_parallel_x86.rs
index 3918590d..b0f8486e 100644
--- a/morello/examples/matmul_batch_parallel_x86.rs
+++ b/morello/examples/matmul_batch_parallel_x86.rs
@@ -12,12 +12,20 @@ use morello::target::{
 };
 use morello::utils::ToWriteFmt;
 use nonzero::nonzero as nz;
+use std::env;
 use std::io;
 
 fn main() {
+    let args: Vec<String> = env::args().collect();
+
     // Compute a batch=4 matrix multiplication. (Four independent matmuls!)
     let mut spec: Spec<X86Target> = spec!(MatmulAccum(
-        [4, 2048, 2048, 2048],
+        [
+            args[1].parse::<u32>().unwrap(),
+            args[2].parse::<u32>().unwrap(),
+            args[3].parse::<u32>().unwrap(),
+            args[4].parse::<u32>().unwrap(),
+        ],
         (f32, GL, row_major),
         (f32, GL, row_major),
         (f32, GL, row_major)
@@ -85,20 +93,16 @@ fn main() {
     }
 
     // Benchmark.
-    const ITERS: u32 = 10;
+    let iterations = std::env::var("CHERRYBENCH_LOOP_STEPS")
+        .unwrap()
+        .parse::<u32>()
+        .unwrap();
     let result = implementation
-        .bench(ITERS, None)
+        .bench(iterations, None)
         .unwrap_or_else(|e| panic!("Failed to benchmark: {}", e));
-    let kernel_runtime =
-        (result.best_inner_loop_runtime() / result.inner_loop_iterations).as_secs_f64();
-    let throughput =
-        result.inner_loop_iterations as f64 / result.best_inner_loop_runtime().as_secs_f64();
-    println!("// kernel runtime: {kernel_runtime:.4}s ({throughput:.2}/sec)",);
-    println!(
-        "// {:.4} gigaFLOPs/sec (Spec is {} FLOPs)",
-        (spec.flops().unwrap() as f64 * throughput) / 1_000_000_000.0,
-        spec.flops().unwrap(),
-    );
+    for duration in &result.inner_loop_runtimes {
+        println!("run: {:.4}s", duration.as_secs_f64());
+    }
 }
 
 fn naive_scalar_move_impl(move_spec: &Spec<X86Target>) -> ImplNode<X86Target> {
